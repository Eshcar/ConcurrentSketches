\section{Quantiles Sketch}
\label{sec:quantiles}

\subsection{Overview}

Given a stream $A$ of items from an ordered domain, for every
$0< \phi < 1$, $\phi - quantile$ of $A$ is an item with rank 
$\lfloor \phi |A| \rfloor$, where the rank of item $i$ is the
number of elements in $A$ smaller than $i$.
An $\epsilon -approximate ~\phi - quantile$ is an element
with rank between $ (\phi - \epsilon) |A|$ and $ (\phi +
\epsilon) |A|$.
For every stream $A$, error $\epsilon$ and probabilty $\delta$,
a quantiles sketch algorithm produces a summary of $A$, which
supports $\epsilon -approximate ~\phi - quantile$ quires for
every $0< \phi < 1$ with probability
at least $1 - \delta$.

As in the Theta sketch presented in the previous section, there
is a tradeoff between summaries space cost and quires accuracy,
which have been widely studied in the past.
In this work we build on top of an algorithm presented
in~\cite{}, which storage cost grows logarithmically with the
input stream size.
Given a stream $A$, the storage cost of the algorithm is
$k*2^{log(\lfloor |A|/k \rfloor)}$, where $k = O((1/\epsilon)
\sqrt{log(1/\epsilon \delta)}$.
The main idea of the algorithm is a simple technique to
\emph{merge} two sets, $S_1$ and $S_2$ of $k$ items each, to a
single set $S$ of $k$ items:
First, set $S = S_1 \cup S_2$, and sort $S$. 
Then, with equal probability, retain either the even or the odd
items in the sorted order. 
This process is called \emph{zip}.


The algorithm maintains $\lfloor log(|A|/k) \rfloor$ weighted
levels, where each level is an array of size $k$ that either contains $k$ ordered
items or invalid (also called empty) (see Figure~\ref{fig:quantilesMerge}.
The weight of level $i$ is $2^{i-1}$.
In addition to the levels arrays, the algorithm uses a
\emph{bitPattern} variable that indicates what levels are valid,
and a \emph{base Buffer} of size $2k$, which is filled with items
from the stream.
Every time the baseBuffer is full, it is propagated (in place) to
the levels arrays in the following way:
First we use the bitPattern to find the first invalid level in
the levels array. 
We call this level the \emph{target} level, and at the end of
the propagation this level will become valid, while all the the
level beneath it will be invalid.
Next, we sort and zip the base buffer (with equal probability,
pick either the even or the odd items in the sorted order) into
the target level.
And then we repeat the following process from level $i=1$ to the
last level that precedes the target level:
Mergesort level $i$ with what is currently stored in the target
level into the base buffer, and then zip the base buffer into the
target level.
Finally, update the bitPatternt to indicate that all the target
level is now valid while all the level beneath are not.

Note that the weight of level $i+1$ is twice the weight of level
$i$ because it was zipped one more time, and thus it
``represents'' twice of the number of items ``represented'' in
level $i$.
This is important for quantiles accuracy.
In order to get a quantile we first have to build an
\emph{auxiliary} object that contains two arrays:
(1) Sorted array of items, \emph{Iarr}, which 
contains all the items from all the valid levels, and (2) an
array of weights, called \emph{Warr}, that maps every item in
Iarr to its weight.
Then, to get the $~\phi - quantile$ of a stream $A$
we need to find the first index $ind$ in $Warr$ such that the
sum of all weights in $Warr$ till index $ind$ is $\lfloor \phi |A|
\rfloor$, and return $Iarr[ind]$.
Figue~\ref{fig:quantilesMerge} illustrates the algorithm.
Since it is not the focus of our paper we omit the error analysis
of the algorithm, and refer the interested reader to~\cite{} for
the proof and more details.

\begin{figure}[H]
    \centering
    \includegraphics[width=3.2in]{images/quantilesPropogation.pdf}
    \caption{Quantile sketch: Propagating base buffer
    into the levels array.}
    \label{fig:quantilesMerge}
\end{figure}


\subsection{Concurrent Algorithm}

An efficient concurrent thread allows for as much work as possible to be executed in parallel.
This is not an easy task since the propagation process (from the base buffer to levels
array), which requires most of the work in the algorithm, is
inherently very sequential.
An alternative option is to decrease the propagation rate without changing
the value of $K$. 
In other words, instead of propagating every $2K$ items we can
do it every $2^{i}K$, where $i \geq 0$ is a parameter that
impacts accuracy (as described below).
This way we amortized the propagation cost and thus increase
throughput.

Our approach given in  Algorithm~\ref{alg:concurrent-quantile} is to exploit locality and minimize
synchronization.
As in the concurrent Theta sketch, the idea is to have one propagation
background thread and many worker threads.
Every worker thread maintains a local sketch with bounded number
of levels; each level stores $b$ items. 
Every time the local sketch fills its last level, and it is the only valid level the content of the last level is propagated to the
shared sketch via the background thread.
For a sketch with $i$ local levels, it happens every $2^ib$
items from the stream (See Figure~\ref{cocurrentQuntiles}).



The optimal number of local levels depends on the number of
concurrent worker threads.
Since  the propagation time is constant more worker threads means each thread gets
less help from the background thread--we need to make sure each thread needs help
less frequently.
For better scalability we need to find the balance between increasing the number of
local levels with the number of worker threads: too much levels means more delay in getting fresh results, not enough levels cause the propagation thread to become a bottleneck.

After triggering propagation to the shared sketch,
a worker thread starts filling its local sketch again, hoping the
propagation process is faster than the filling process.
As in the Theta sketch, the synchronization between the
propagation thread and a worker thread $t_i$ is done over a
single atomic variable $P_i$.

To propagate level $i$ from a local sketch to the shared sketch,
the propagation thread applies the mechanism of the
sequential quantiles sketch with the following
change:
Instead of starting from zipping the base buffer
into the target level, it starts from level $i$.
If level $i$ in the shared sketch is valid, the propagation
thread merges it (via merge sort) with the local level $i$ into
the base buffer, and continues the propagation to the next level
as before.
Otherwise, it simple copies the local level $i$ to the shared level
$i$.
The target buffer in this case is the first invalid level that is
not smaller than $i$.

Recall that in order to read (getQuantiles), readers build an
auxiliary object based on the levels array and the bitPattern
that describes it.
Therefore, to be able to read concurrently with
background propagation, a reader must obtain a snapshot of the
levels array.
We solve this with the double successful collect technique~\cite{}.
First, we define an atomic bitPatern so
that a propagation is visible to all readers after the
bitPattern is updated.
Second, a reader repeatedly tries to obtain a consistent view of
the levels array: it reads the bitPattern, then the levels array,
and then the bitPattern again.
If the bit pattern did not change between the two reads, the
reader has a consistent view.
Otherwise, it tries again.

Note that during the propagation process, the background
thread may read many levels, but write only to the target level,
which is invalid at this point.
Therefore, a reader can be sure that the valid levels it reads
between two identical reads of the bitPatern are consistent
even though the background thread is
propagating in parallel.
In addition, note that a reader do not have to read all valid
levels each time it fails to obtain a successful double collect.
Since a valid level may become invalid and then valid again
(with different items) only after a higher invalid level becomes
valid, if two sequential reads of the bitPatern has a
common suffix, the reader must read only the valid levels in
the different prefix of the later bitPattern read. 
It is guaranteed that the valid levels in the suffix are
unchanged.

The reads in this algorithm may suffer from starvation due to repeated changes of the bitPatern which makes it impossible for the readers to get a consistent snapshot..
In practice, however, the propagation time (and thus
the time between bitPattern changes) is longer when the target
level is higher, and every once in a while the background thread must
propagate to a high level.
So, eventually the propagation is long enough for
all the reader to obtain a snapshot of the levels array. 
The experiments we ran, show that the readers are able to do it
much faster, and the snapshot time is negligible with respect to the time it takes to
build the auxiliary object.

\begin{algorithm*}[tb]
\small
\begin{multicols}{2}
\begin{algorithmic}[1]

%\State {\bf Sketch variables:}
\Vars
\State \emph{buf}, init $[ ]$ \Comment global samples
\State \emph{bitPattern}, init 0 \Comment global bit array of valid levels
\Statex
\ForEach{update thread $t_i$}
	\State \emph{q$_i$}, init empty \Comment local quantile sketch
	\State \emph{aux$_i$}, init $[ ]$ \Comment auxiliary array
	\State {\tt atomic} $P_i$, init $1$ \Comment for synchronization
\EndFor
\EndFor

\Statex
\Procedure{query}{$\phi$}
\State \emph{snapshot} $\leftarrow$ \emph{DoubleCollect(buf, bitPattern)}
\ForAll{valid \emph{lvl} in \emph{snapshot.bitPttern}} \label{l:caught-snapshot}
	\ForAll{\emph{sample} in \emph{snapshot.buf[lvl]}}
		\State append $\langle$\emph{sample},\emph{$2^{lvl}$}$\rangle$ to \emph{tuples}
	\EndFor
\EndFor
\State sort $tuples$ by $sample$
\State $pos \leftarrow \min {\{\lfloor N \times \phi \rfloor, N-1\}}$
\State $sum \leftarrow 0$
\State $ind \leftarrow 0$
\While{$sum \leq pos$}
	\State $sum \leftarrow sum + tuples[ind].weight$
	\State $ind \leftarrow ind + 1$
\EndWhile
\State \Return $tuples[ind-1].sample$ 
\EndProcedure
%\Statex

\Procedure{update$_i$}{$val$}
\State insert $val$ into $q_i$
\If{level $L$ in $q_i$ is the single valid full level }
		\State wait until $P_i>0$
		\State $aux_i \leftarrow$ level $L$ in $q_i$
		\State $P_i \leftarrow$ 0
		\State reset $q_i$
\EndIf
\EndProcedure

\Procedure{propagator}{}
\While {true}
\ForAll{update thread $t_i$ s.t. $P_i =0$}
		\State $tmpK \leftarrow aux_i$
		\State $P_i \leftarrow 1$
		\State \emph{target} $\leftarrow$ leftmost zero bit in \emph{bitPattern} $\leq L$
		\State \emph{bitPatternMask} $\leftarrow$ 0
		\For{$i \in \{L,\dots,target-1\}$}
				\State \emph{tmp2K} $\leftarrow$ mergeSort of \emph{tmpK} with \emph{buf[i]}
				\State \emph{tmpK} $\leftarrow$ zip \emph{tmp2K} \label{l:zip}
				\State set bit \emph{i} in \emph{bitPatternMask} to 1
		\EndFor
		\State \emph{buf[target]} $\leftarrow$ \emph{tmpk}
		\State set bit \emph{target} in \emph{bitPatternMask} to 1
		\State \emph{bitPattern} $\Leftarrow$ \emph{bitPattern} $\oplus$ \emph{bitPatternMask}
		\State $N \leftarrow N + K \times 2^{L}$
\EndFor
\EndWhile
\EndProcedure

\end{algorithmic}
\end{multicols}
\caption{Concurrent Quantile sketch algorithm. Maximum level in local sketches is $L$.}
\label{alg:concurrent-quantile}
\end{algorithm*}


\begin{figure}[tb]
    \centering
    \includegraphics[width=3.5in]{images/cocurrentQuntiles.pdf}
    \caption{Concurrent Quantiles sketch architecture.}
    \label{cocurrentQuntiles}
\end{figure}

